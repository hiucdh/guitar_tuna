import 'dart:io';
import 'dart:typed_data';

void main() {
  final inputFile = File('assets/sounds/temp_raw.wav');
  final outputFile = File('assets/sounds/tick.wav');

  if (!inputFile.existsSync()) {
    print('Error: Input file exists not.');
    return;
  }

  final bytes = inputFile.readAsBytesSync();
  
  // Basic WAV parsing (assuming standard header generated by afconvert)
  // Header is usually 44 bytes.
  // We want 1 second. Sample rate is at offset 24 (4 bytes).
  // Bits per sample at offset 34 (2 bytes).
  // Num channels at offset 22 (2 bytes).
  
  final ByteData byteData = bytes.buffer.asByteData();
  final int sampleRate = byteData.getUint32(24, Endian.little);
  final int numChannels = byteData.getUint16(22, Endian.little);
  final int bitsPerSample = byteData.getUint16(34, Endian.little); // usually 16

  print('Detected: $sampleRate Hz, $numChannels channels, $bitsPerSample bits');

  final int bytesPerSample = bitsPerSample ~/ 8;
  final int bytesPerSecond = sampleRate * numChannels * bytesPerSample;
  
  final int headerSize = 44; // Standard WAV header size
  // Find 'data' chunk if it's not at 36. afconvert might add flexible chunks.
  // A robust parser would scan for 'data', but for now let's assume standard or scan briefly.
  
  int dataOffset = 12;
  while (dataOffset < bytes.length) {
    String chunkId = String.fromCharCodes(bytes.sublist(dataOffset, dataOffset + 4));
    int chunkSize = byteData.getUint32(dataOffset + 4, Endian.little);
    if (chunkId == 'data') {
      dataOffset += 8;
      break;
    }
    dataOffset += 8 + chunkSize;
  }
  
  print('Data starts at offset: $dataOffset');

  // We want 1 second of data
  int targetDataSize = bytesPerSecond; // 1 second
  if (dataOffset + targetDataSize > bytes.length) {
    targetDataSize = bytes.length - dataOffset;
    print('Warning: File is shorter than 1 second, copying all data.');
  }

  final outputBytes = BytesBuilder();
  
  // Write Header
  // ChunkID
  outputBytes.add('RIFF'.codeUnits);
  // ChunkSize (FileSize - 8)
  outputBytes.add(_int32(36 + targetDataSize));
  // Format
  outputBytes.add('WAVE'.codeUnits);
  
  // Subchunk1 (fmt) - reusing from input for simplicity (copy 16 bytes + header 8)
  // Assuming standard fmt chunk of size 16.
  outputBytes.add('fmt '.codeUnits);
  outputBytes.add(_int32(16));
  outputBytes.add(_int16(1)); // PCM
  outputBytes.add(_int16(numChannels));
  outputBytes.add(_int32(sampleRate));
  outputBytes.add(_int32(bytesPerSecond)); // ByteRate
  outputBytes.add(_int16(numChannels * bytesPerSample)); // BlockAlign
  outputBytes.add(_int16(bitsPerSample)); // BitsPerSample
  
  // Subchunk2 (data)
  outputBytes.add('data'.codeUnits);
  outputBytes.add(_int32(targetDataSize));
  
  // Data
  outputBytes.add(bytes.sublist(dataOffset, dataOffset + targetDataSize));

  outputFile.writeAsBytesSync(outputBytes.toBytes());
  print('Successfully created tick.wav (1 second)');
}

List<int> _int32(int value) {
  var b = ByteData(4);
  b.setInt32(0, value, Endian.little);
  return b.buffer.asUint8List();
}

List<int> _int16(int value) {
  var b = ByteData(2);
  b.setInt16(0, value, Endian.little);
  return b.buffer.asUint8List();
}
